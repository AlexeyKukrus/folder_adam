_Хуки_ — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React без написания классов.

**1. useState - предоставляет функциональным компонентам возможность иметь state**
Он используется для объявления переменной состояния внутри функционального компонента и предоставляет способ обновления этого состояния.
```javascript 
const [state, setState] = useState(initialValue);
```
ВОЗВРАЩАЕТ:
**state** - переменная состояния, которую мы объявляем. 
**setState** - функция, которая позволяет обновлять значение переменной состояния.

ПРИНИМАЕТ:
**initialValue** - начальное значение переменной состояния. 
```JSX
import React, { useState } from 'react'; 

function Example() {
	const [count, setCount] = useState(0);
	return (
		<div>
			<p>Вы кликнули {count} раз(а)</p>
			<button onClick={() => setCount(count + 1)}>
				Нажми на меня
			</button>
		</div>
	);
}
```
**2. useEffect - даёт возможность выполнять побочные эффекты в функциональном компоненте.**
useEffect может является альтернативой методам жизненного цикла в классовых компонентах. Он позволяет выполнять побочные эффекты в функциональном компоненте, такие как изменение DOM, выполнение запросов к серверу, подписка на события и т.д. Также он позволяет возвращать функцию очистки, которая будет выполнена перед удалением компонента или перед вызовом нового эффекта. Это может быть полезно для отписки от событий или отмены запросов.

**Хук useEffect принимает два аргумента:** колбэк-функцию и массив зависимостей. Колбэк-функция представляет собой код, который будет выполнен каждый раз, когда компонент будет отрисовываться или обновляться. Массив зависимостей определяет, при каких изменениях состояния колбэк-функция должна быть вызвана.
	Например, 
	- Если массив зависимостей пустой, колбэк-функция будет вызываться после каждого рендера компонента. Таким образом эмулируется работа метода componentDidMount
	- Если массив зависимостей не указан, колбэк-функция будет вызываться только после первого рендера компонента. 
	- Если массив зависимостей содержит значения, useEffect будет следить за изменениями этих значений. Колбэк-функция будет вызываться только при изменении хотя бы одного из этих значений. Таким образом эмулируется работа метода componentDidUpdate

Хук useEffect не возвращает никакого значения напрямую, а только опциональную функцию очистки.
	Если вы хотите использовать функцию очистки, она должна быть возвращена из функции-колбэка внутри useEffect. Когда компонент удаляется или эффект перестает использоваться (например, при изменении зависимостей), функция очистки будет вызвана.
```JSX
useEffect(() => {
  // Код, который будет выполнен после первого рендера компонента (аналог componentDidMount)
}, []);

useEffect(() => {
  // Код, который будет выполнен при изменении зависимости (аналог componentDidUpdate)
}, [dependency]);

useEffect(() => {
  return () => {
    // Код для очистки (аналог componentWillUnmount)
  };
}, []);

useEffect(() => {
  // Код, который будет выполнен при изменении любой из зависимостей (аналог componentDidUpdate)
}, [dependency1, dependency2]);
```
**3. useLayoutEffect - очень похож на хук useEffect, но с некоторыми различиями в том, когда он вызывается.**
Хук useLayoutEffect запускает функцию-эффект после завершения базовой отрисовки (render) компонента, но перед тем, как браузер обновит экран. Использование этого хука может быть полезно для работы с DOM-элементами, так как он гарантирует, что ваш эффект будет запущен синхронно с фактической отрисовкой DOM.

Различия между useEffect и useLayoutEffect:
- useEffect вызывается после того, как браузер завершил обновление экрана и пользователь скорее всего уже видит обновленный контент, тогда как useLayoutEffect вызывается перед браузерным обновлением экрана.
- Использование useLayoutEffect может приводить к блокировке интерфейса до тех пор, пока функция-эффект не завершится, поэтому его следует использовать с осторожностью и только в тех случаях, когда это необходимо для корректной отрисовки.

Вот пример использования useLayoutEffect для управления DOM-элементами:
```JSX
import React, { useLayoutEffect, useRef } from 'react';

function MyComponent() {
  const ref = useRef();

  useLayoutEffect(() => {
    // Используем ref для доступа к DOM-элементу в браузере
    const element = ref.current;
    // Делаем что-то с элементом...
    // Очищаем эффект при размонтировании компонента
    return () => {
      // Очищаем или отменяем побочные эффекты
    };
  }, [/* dependencies */]);

  return <div ref={ref}>My Component</div>;
}
```
В этом примере наш эффект будет вызван после завершения отрисовки, но перед браузерным обновлением экрана. Мы можем использовать ref для получения доступа к DOM-элементу и делать необходимые манипуляции с ним.

Обратите внимание, что использование useLayoutEffect должно быть осознанным и осторожным, так как он может влиять на производительность и отзывчивость интерфейса. Он редко требуется, и зачастую можно использовать useEffect для управления побочными эффектами.

**4. useReducer -  используется для управления состоянием компонента на основе редьюсера, который является функцией обновления состояния.**
Он предоставляет возможность более сложного управления состоянием, чем хук useState, и может быть особенно полезен в случае компонентов с более сложной логикой обновления состояния.
Чтобы использовать хук useReducer, необходимо выполнить следующие шаги:
1. Создать редьюсер - это функция, которая принимает текущее состояние и действие, и возвращает новое состояние. Редьюсер должен быть чистой функцией, то есть не должен изменять текущее состояние напрямую, а возвращать новое состояние на основе текущего состояния и действия.
2. Использовать хук useReducer в компоненте:
```JSX
//reducer.js
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1;
    case 'DECREMENT':
      return state - 1;
    default:
      return state;
  }
}

export default reducer

//component.js
import React, { useReducer } from 'react';
import reducer from './reducer'
function MyComponent() {
  const [state, dispatch] = useReducer(reducer, 0);
  
  // state - текущее состояние
  // dispatch - функция, которую можно вызывать для отправки действия в редьюсер

  return (
    <div>
      <p>Состояние: {state}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>Увеличить</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>Уменьшить</button>
    </div>
  );
}
```
**5. useCallback - помогает предотвратить создание новых экземпляров функций при каждом рендеринге**
`useCallback` - это один из хуков в React, который используется для оптимизации производительности, особенно в контексте рендеринга функциональных компонентов. Этот хук помогает предотвратить создание новых экземпляров функций при каждом рендеринге, что может быть полезным в определенных случаях.

Когда использовать `useCallback`:
1. **Предотвращение избыточных рендеров:**
    - Когда вы передаете функцию в дочерний компонент, каждый раз, когда происходит рендер родительского компонента, создается новая функция. Использование `useCallback` помогает избежать этой проблемы, сохраняя один и тот же экземпляр функции между рендерами.
2. **Оптимизация использования памяти:**
    - Если функция не зависит от изменяемых данных или состояния, использование `useCallback` может уменьшить использование памяти, так как повторное использование одного и того же экземпляра функции более эффективно.
3. **Оптимизация передачи функций в зависимости:**
    - Когда функции используются в зависимостях других хуков, `useCallback` может помочь в предотвращении повторных вызовов этих хуков.
```JSX
import React, { useState, useEffect, useCallback } from 'react';

const ExampleComponent = () => {
  const [count, setCount] = useState(0);
  const [data, setData] = useState(null);

  // Некоторая функция-хук, которая загружает данные
  const fetchData = useCallback(async () => {
    try {
      // Предположим, что это асинхронный запрос к API
      const response = await fetch('https://api.example.com/data');
      const result = await response.json();
      setData(result);
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  }, []);

  // Используем useEffect для запуска fetchData при изменении count
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Data: {data ? JSON.stringify(data) : 'Loading...'}</p>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>
        Increment Count
      </button>
    </div>
  );
};

export default ExampleComponent;

```
В этом примере:

- `fetchData` - это функция, которая используется для асинхронной загрузки данных. Она определена с использованием `useCallback`, чтобы предотвратить ее повторное создание при каждом рендеринге компонента.
- `useEffect` используется для запуска `fetchData` при изменении `count`. Благодаря использованию `useCallback` с зависимостью `[]`, `fetchData` не изменяется между рендерами, и `useEffect` не будет перезапускаться из-за изменения `fetchData`.

Это важно, потому что без `useCallback` каждый раз при изменении `count` создавался бы новый экземпляр `fetchData`, что могло бы привести к ненужным повторным запросам данных. Используя `useCallback`, мы гарантируем, что `fetchData` сохраняется между рендерами и не вызывается повторно при изменении других зависимостей в `useEffect`.

 Пример использования `useCallback`:

```JSX
import React, { useState, useCallback } from 'react';

const ExampleComponent = () => {
  const [count, setCount] = useState(0);

  // Без использования useCallback
  const incrementWithoutCallback = () => {
    setCount(count + 1);
  };

  // С использованием useCallback
  const incrementWithCallback = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []); // Пустой массив зависимостей, потому что нет зависимостей от внешних данных

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={incrementWithoutCallback}>Increment (без useCallback)</button>
      <button onClick={incrementWithCallback}>Increment (с useCallback)</button>
    </div>
  );
};

export default ExampleComponent;

```

Здесь `incrementWithoutCallback` создает новую функцию при каждом рендеринге, в то время как `incrementWithCallback` использует `useCallback`, чтобы сохранить один и тот же экземпляр функции между рендерами.

Обратите внимание, что использование `useCallback` имеет смысл только тогда, когда это действительно необходимо для оптимизации производительности, и не следует использовать его всегда. В большинстве случаев React хорошо управляет рендерингом и перерендериванием компонентов без дополнительных оптимизаций.

**6. useMemo - мемоизирует значение и возвращает его кэшированную версию**

**7. useContext - хук, которы позволяет функциональным компонентам получать доступ к значению контекста. Контекст используется для передачи данных без явной передачи пропсов**

**8. useRef - **

**9. useId - предназначен для генерации уникальных идентификаторов**
Решает проблему с придумыванием собственного id. Например, когда мы хотим привязать input к lable через htmlfor нам придется придумывать уникальный id, которого нет на странице и так далее. Можно использовать этот хук
```jsx
import { useId } from 'react';

const App = () => {
	const id = useId();
	return(
		<div>
			<label htmlFor={id}>Someinput</label>
			<InfoIcon />
			<input name='some-input' id={id} />
		</div>
	);
};
```
Решает проблему не совпадения id при SSR. Когда на сервере генерируется один id, а на клиенте потом другой.

**10. useTransition - позволяет обновлять состояния без блокирования UI.**
Если у нас есть какая-то тяжелая операция, которая при выполнении будет занимать некоторое время, например:
- при нажатии кнопки заполнить массив 20000 элементами и вывести на экран, а на кнопке выводить счетчик
- после каждого удаления символа из инпута делать fetch запрос для поиска совпадений
 то при каждом событии мы будем видеть задержку
```JSX
const [isPending, startTransition] = useTransition();

startTransition(() => {...действие, которое должно стать не срочным})
```
- isPending - это булево состояние, которое позволяет узнать, происходит ли в данный момент переход, анимация или другой асинхронный процесс. Он указывает, что переход еще не завершился и всё еще находится в процессе изменения. Это может быть полезно для определения состояния, когда переход активен, и, например, блокировки других действий пользователя до завершения перехода.
- startTransition - это функция, которая позволяет запустить переход (транзакцию) и начать процесс изменения состояния или выполнения асинхронной операции. Она принимает коллбэк-функцию, которая выполняет фактическое изменение состояния. startTransition пометит это изменение как неважное и отложит до следующего рендера. 

**11. useDefferedValue - позволяет откладывать обновление части UI**
```jsx
const deferredValue = useDeferredValue(value);
```
Выполняет тот же функционал, что и useTransition, только принимает props, а не callback

**12. useImperativeHandle() - позволяет определить функции, которые должны быть доступны родительскому компоненту.**

пометка BATCHING - состояние меняется дважды, но рендер - 1

