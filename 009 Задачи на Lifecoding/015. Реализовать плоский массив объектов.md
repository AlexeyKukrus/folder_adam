**Дан массив объектов arr1, каждый из которых содержит свойство next — массив вложенных объектов. Реализуйте функцию flattenObj(arr), которая преобразует данную структуру в плоский массив объектов.**

```javascript
const arr1 = [ 
	{ 
		id: 1, 
		next: [{ id: 2 }, { id: 3 }, { id: 4 }], 
	}, 
	{ 
		id: 5, 
		next: [{ id: 6 }, { id: 7 }, { id: 8 }] 
	}, 
]; 

function flattenObj(arr) {} 

console.log(flattenObj(arr1)); 
//[ { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }, { id: 6 }, { id: 7 }, { id: 8 } ]
```

Решение:
1. В stack передаем исходный массив, а в res будем передавать результат.
2. Пишем цикл while, который будет выполняться до тех пор, пока стеке что-то есть
3. Извлекаем из стека верхний узел и передаем его в переменную node.
4. Пишем цикл, который будет пробегаться по элементам текущего узла и проверяем элемент, каким он является (массивом или элементом с ключом id)
5. Если свойство имеет ключ "id", создается новый объект и добавляется в массив res.
    Если свойство содержит массив, каждый объект массива добавляется в стек для последующего обхода.
6. По завершении цикла возвращается отсортированный массив объектов по ключу "id".

```javascript
function flattenObj(arr) {
	let stack = [...arr];
	let res = [];
	while (stack.length) {
	    let node = stack.pop();
	    for (let key in node) {
		    // нужно, чтобы перебирались только ключи, без прототипов
			if (node.hasOwnProperty(key)) { 
		        if (key === "id") res.push({ id: node[key] });
		        if (Array.isArray(node[key])) node[key].forEach((obj) => 
			    stack.push(obj));
			}
	    }
  }
  return res.sort((a, b) => a.id - b.id);
}

// Пример использования
const arr1 = [
  {
    id: 1,
    next: [{ id: 2 }, { id: 3 }, { id: 4 }],
  },
  { id: 5, next: [{ id: 6 }, { id: 7 }, { id: 8 }] },
];

console.log(flattenObj(arr1));
```
